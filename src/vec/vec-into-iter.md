# ƗռȶօƗȶɛʀ

Łɛȶ'ֆ ʍօʋɛ օռ ȶօ աʀɨȶɨռɢ ɨȶɛʀǟȶօʀֆ. `ɨȶɛʀ` ǟռɖ `ɨȶɛʀ_ʍʊȶ` ɦǟʋɛ ǟʟʀɛǟɖʏ ɮɛɛռ
աʀɨȶȶɛռ ʄօʀ ʊֆ ȶɦǟռӄֆ ȶօ Ƭɦɛ Ɱǟɢɨƈ օʄ Ɖɛʀɛʄ. Ӈօաɛʋɛʀ ȶɦɛʀɛ'ֆ ȶաօ ɨռȶɛʀɛֆȶɨռɢ
ɨȶɛʀǟȶօʀֆ ȶɦǟȶ Ʋɛƈ քʀօʋɨɖɛֆ ȶɦǟȶ ֆʟɨƈɛֆ ƈǟռ'ȶ: `ɨռȶօ_ɨȶɛʀ` ǟռɖ `ɖʀǟɨռ`.

ƗռȶօƗȶɛʀ ƈօռֆʊʍɛֆ ȶɦɛ Ʋɛƈ ɮʏ-ʋǟʟʊɛ, ǟռɖ ƈǟռ ƈօռֆɛզʊɛռȶʟʏ ʏɨɛʟɖ ɨȶֆ ɛʟɛʍɛռȶֆ
ɮʏ-ʋǟʟʊɛ. Ɨռ օʀɖɛʀ ȶօ ɛռǟɮʟɛ ȶɦɨֆ, ƗռȶօƗȶɛʀ ռɛɛɖֆ ȶօ ȶǟӄɛ ƈօռȶʀօʟ օʄ Ʋɛƈ'ֆ
ǟʟʟօƈǟȶɨօռ.

ƗռȶօƗȶɛʀ ռɛɛɖֆ ȶօ ɮɛ ƉօʊɮʟɛƐռɖɛɖ ǟֆ աɛʟʟ, ȶօ ɛռǟɮʟɛ ʀɛǟɖɨռɢ ʄʀօʍ ɮօȶɦ ɛռɖֆ.
Ʀɛǟɖɨռɢ ʄʀօʍ ȶɦɛ ɮǟƈӄ ƈօʊʟɖ ʝʊֆȶ ɮɛ ɨʍքʟɛʍɛռȶɛɖ ǟֆ ƈǟʟʟɨռɢ `քօք`, ɮʊȶ ʀɛǟɖɨռɢ
ʄʀօʍ ȶɦɛ ʄʀօռȶ ɨֆ ɦǟʀɖɛʀ. Ɯɛ ƈօʊʟɖ ƈǟʟʟ `ʀɛʍօʋɛ(0)` ɮʊȶ ȶɦǟȶ աօʊʟɖ ɮɛ ɨռֆǟռɛʟʏ
ɛӼքɛռֆɨʋɛ. Ɨռֆȶɛǟɖ աɛ'ʀɛ ɢօɨռɢ ȶօ ʝʊֆȶ ʊֆɛ քȶʀ::ʀɛǟɖ ȶօ ƈօքʏ ʋǟʟʊɛֆ օʊȶ օʄ
ɛɨȶɦɛʀ ɛռɖ օʄ ȶɦɛ Ʋɛƈ աɨȶɦօʊȶ ʍʊȶǟȶɨռɢ ȶɦɛ ɮʊʄʄɛʀ ǟȶ ǟʟʟ.

Ƭօ ɖօ ȶɦɨֆ աɛ'ʀɛ ɢօɨռɢ ȶօ ʊֆɛ ǟ ʋɛʀʏ ƈօʍʍօռ Ƈ ɨɖɨօʍ ʄօʀ ǟʀʀǟʏ ɨȶɛʀǟȶɨօռ. Ɯɛ'ʟʟ
ʍǟӄɛ ȶաօ քօɨռȶɛʀֆ; օռɛ ȶɦǟȶ քօɨռȶֆ ȶօ ȶɦɛ ֆȶǟʀȶ օʄ ȶɦɛ ǟʀʀǟʏ, ǟռɖ օռɛ ȶɦǟȶ
քօɨռȶֆ ȶօ օռɛ-ɛʟɛʍɛռȶ քǟֆȶ ȶɦɛ ɛռɖ. Ɯɦɛռ աɛ աǟռȶ ǟռ ɛʟɛʍɛռȶ ʄʀօʍ օռɛ ɛռɖ, աɛ'ʟʟ
ʀɛǟɖ օʊȶ ȶɦɛ ʋǟʟʊɛ քօɨռȶɛɖ ȶօ ǟȶ ȶɦǟȶ ɛռɖ ǟռɖ ʍօʋɛ ȶɦɛ քօɨռȶɛʀ օʋɛʀ ɮʏ օռɛ. Ɯɦɛռ
ȶɦɛ ȶաօ քօɨռȶɛʀֆ ǟʀɛ ɛզʊǟʟ, աɛ ӄռօա աɛ'ʀɛ ɖօռɛ.

Ռօȶɛ ȶɦǟȶ ȶɦɛ օʀɖɛʀ օʄ ʀɛǟɖ ǟռɖ օʄʄֆɛȶ ǟʀɛ ʀɛʋɛʀֆɛɖ ʄօʀ `ռɛӼȶ` ǟռɖ `ռɛӼȶ_ɮǟƈӄ`
Ƒօʀ `ռɛӼȶ_ɮǟƈӄ` ȶɦɛ քօɨռȶɛʀ ɨֆ ǟʟաǟʏֆ ǟʄȶɛʀ ȶɦɛ ɛʟɛʍɛռȶ ɨȶ աǟռȶֆ ȶօ ʀɛǟɖ ռɛӼȶ,
աɦɨʟɛ ʄօʀ `ռɛӼȶ` ȶɦɛ քօɨռȶɛʀ ɨֆ ǟʟաǟʏֆ ǟȶ ȶɦɛ ɛʟɛʍɛռȶ ɨȶ աǟռȶֆ ȶօ ʀɛǟɖ ռɛӼȶ.
Ƭօ ֆɛɛ աɦʏ ȶɦɨֆ ɨֆ, ƈօռֆɨɖɛʀ ȶɦɛ ƈǟֆɛ աɦɛʀɛ ɛʋɛʀʏ ɛʟɛʍɛռȶ ɮʊȶ օռɛ ɦǟֆ ɮɛɛռ
ʏɨɛʟɖɛɖ.

Ƭɦɛ ǟʀʀǟʏ ʟօօӄֆ ʟɨӄɛ ȶɦɨֆ:

```text
          S  E
[X, X, X, O, X, X, X]
```

Ɨʄ Ɛ քօɨռȶɛɖ ɖɨʀɛƈȶʟʏ ǟȶ ȶɦɛ ɛʟɛʍɛռȶ ɨȶ աǟռȶɛɖ ȶօ ʏɨɛʟɖ ռɛӼȶ, ɨȶ աօʊʟɖ ɮɛ
ɨռɖɨֆȶɨռɢʊɨֆɦǟɮʟɛ ʄʀօʍ ȶɦɛ ƈǟֆɛ աɦɛʀɛ ȶɦɛʀɛ ǟʀɛ ռօ ʍօʀɛ ɛʟɛʍɛռȶֆ ȶօ ʏɨɛʟɖ.

Ǟʟȶɦօʊɢɦ աɛ ɖօռ'ȶ ǟƈȶʊǟʟʟʏ ƈǟʀɛ ǟɮօʊȶ ɨȶ ɖʊʀɨռɢ ɨȶɛʀǟȶɨօռ, աɛ ǟʟֆօ ռɛɛɖ ȶօ ɦօʟɖ
օռȶօ ȶɦɛ Ʋɛƈ'ֆ ǟʟʟօƈǟȶɨօռ ɨռʄօʀʍǟȶɨօռ ɨռ օʀɖɛʀ ȶօ ʄʀɛɛ ɨȶ օռƈɛ ƗռȶօƗȶɛʀ ɨֆ
ɖʀօքքɛɖ.

Ֆօ աɛ'ʀɛ ɢօɨռɢ ȶօ ʊֆɛ ȶɦɛ ʄօʟʟօաɨռɢ ֆȶʀʊƈȶ:

<!-- ignore: simplified code -->
```rust,ignore
pub struct IntoIter<T> {
    buf: NonNull<T>,
    cap: usize,
    start: *const T,
    end: *const T,
}
```

Ǟռɖ ȶɦɨֆ ɨֆ աɦǟȶ աɛ ɛռɖ ʊք աɨȶɦ ʄօʀ ɨռɨȶɨǟʟɨʐǟȶɨօռ:

<!-- ignore: simplified code -->
```rust,ignore
impl<T> IntoIterator for Vec<T> {
    type Item = T;
    type IntoIter = IntoIter<T>;
    fn into_iter(self) -> IntoIter<T> {
        // Make sure not to drop Vec since that would free the buffer
        let vec = ManuallyDrop::new(self);

        // Can't destructure Vec since it's Drop
        let ptr = vec.ptr;
        let cap = vec.cap;
        let len = vec.len;

        IntoIter {
            buf: ptr,
            cap,
            start: ptr.as_ptr(),
            end: if cap == 0 {
                // can't offset off this pointer, it's not allocated!
                ptr.as_ptr()
            } else {
                unsafe { ptr.as_ptr().add(len) }
            },
        }
    }
}
```

Ӈɛʀɛ'ֆ ɨȶɛʀǟȶɨռɢ ʄօʀաǟʀɖ:

<!-- ignore: simplified code -->
```rust,ignore
impl<T> Iterator for IntoIter<T> {
    type Item = T;
    fn next(&mut self) -> Option<T> {
        if self.start == self.end {
            None
        } else {
            unsafe {
                let result = ptr::read(self.start);
                self.start = self.start.offset(1);
                Some(result)
            }
        }
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        let len = (self.end as usize - self.start as usize)
                  / mem::size_of::<T>();
        (len, Some(len))
    }
}
```

Ǟռɖ ɦɛʀɛ'ֆ ɨȶɛʀǟȶɨռɢ ɮǟƈӄաǟʀɖֆ.

<!-- ignore: simplified code -->
```rust,ignore
impl<T> DoubleEndedIterator for IntoIter<T> {
    fn next_back(&mut self) -> Option<T> {
        if self.start == self.end {
            None
        } else {
            unsafe {
                self.end = self.end.offset(-1);
                Some(ptr::read(self.end))
            }
        }
    }
}
```

Ɓɛƈǟʊֆɛ ƗռȶօƗȶɛʀ ȶǟӄɛֆ օառɛʀֆɦɨք օʄ ɨȶֆ ǟʟʟօƈǟȶɨօռ, ɨȶ ռɛɛɖֆ ȶօ ɨʍքʟɛʍɛռȶ Ɖʀօք
ȶօ ʄʀɛɛ ɨȶ. Ӈօաɛʋɛʀ ɨȶ ǟʟֆօ աǟռȶֆ ȶօ ɨʍքʟɛʍɛռȶ Ɖʀօք ȶօ ɖʀօք ǟռʏ ɛʟɛʍɛռȶֆ ɨȶ
ƈօռȶǟɨռֆ ȶɦǟȶ աɛʀɛռ'ȶ ʏɨɛʟɖɛɖ.

<!-- ignore: simplified code -->
```rust,ignore
impl<T> Drop for IntoIter<T> {
    fn drop(&mut self) {
        if self.cap != 0 {
            // drop any remaining elements
            for _ in &mut *self {}
            let layout = Layout::array::<T>(self.cap).unwrap();
            unsafe {
                alloc::dealloc(self.buf.as_ptr() as *mut u8, layout);
            }
        }
    }
}
```
