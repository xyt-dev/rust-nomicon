# Ֆɛռɖ ǟռɖ Ֆʏռƈ

Ռօȶ ɛʋɛʀʏȶɦɨռɢ օɮɛʏֆ ɨռɦɛʀɨȶɛɖ ʍʊȶǟɮɨʟɨȶʏ, ȶɦօʊɢɦ. Ֆօʍɛ ȶʏքɛֆ ǟʟʟօա ʏօʊ ȶօ
ɦǟʋɛ ʍʊʟȶɨքʟɛ ǟʟɨǟֆɛֆ օʄ ǟ ʟօƈǟȶɨօռ ɨռ ʍɛʍօʀʏ աɦɨʟɛ ʍʊȶǟȶɨռɢ ɨȶ. Ʊռʟɛֆֆ ȶɦɛֆɛ ȶʏքɛֆ ʊֆɛ
ֆʏռƈɦʀօռɨʐǟȶɨօռ ȶօ ʍǟռǟɢɛ ȶɦɨֆ ǟƈƈɛֆֆ, ȶɦɛʏ ǟʀɛ ǟɮֆօʟʊȶɛʟʏ ռօȶ ȶɦʀɛǟɖ-ֆǟʄɛ. Ʀʊֆȶ
ƈǟքȶʊʀɛֆ ȶɦɨֆ ȶɦʀօʊɢɦ ȶɦɛ `Ֆɛռɖ` ǟռɖ `Ֆʏռƈ` ȶʀǟɨȶֆ.

* Ǟ ȶʏքɛ ɨֆ Ֆɛռɖ ɨʄ ɨȶ ɨֆ ֆǟʄɛ ȶօ ֆɛռɖ ɨȶ ȶօ ǟռօȶɦɛʀ ȶɦʀɛǟɖ.
* Ǟ ȶʏքɛ ɨֆ Ֆʏռƈ ɨʄ ɨȶ ɨֆ ֆǟʄɛ ȶօ ֆɦǟʀɛ ɮɛȶաɛɛռ ȶɦʀɛǟɖֆ (Ƭ ɨֆ Ֆʏռƈ ɨʄ ǟռɖ օռʟʏ ɨʄ `&Ƭ` ɨֆ Ֆɛռɖ).

Ֆɛռɖ ǟռɖ Ֆʏռƈ ǟʀɛ ʄʊռɖǟʍɛռȶǟʟ ȶօ Ʀʊֆȶ'ֆ ƈօռƈʊʀʀɛռƈʏ ֆȶօʀʏ. Ǟֆ ֆʊƈɦ, ǟ
ֆʊɮֆȶǟռȶɨǟʟ ǟʍօʊռȶ օʄ ֆքɛƈɨǟʟ ȶօօʟɨռɢ ɛӼɨֆȶֆ ȶօ ʍǟӄɛ ȶɦɛʍ աօʀӄ ʀɨɢɦȶ. Ƒɨʀֆȶ ǟռɖ
ʄօʀɛʍօֆȶ, ȶɦɛʏ'ʀɛ [ʊռֆǟʄɛ ȶʀǟɨȶֆ]. Ƭɦɨֆ ʍɛǟռֆ ȶɦǟȶ ȶɦɛʏ ǟʀɛ ʊռֆǟʄɛ ȶօ
ɨʍքʟɛʍɛռȶ, ǟռɖ օȶɦɛʀ ʊռֆǟʄɛ ƈօɖɛ ƈǟռ ǟֆֆʊʍɛ ȶɦǟȶ ȶɦɛʏ ǟʀɛ ƈօʀʀɛƈȶʟʏ
ɨʍքʟɛʍɛռȶɛɖ. Ֆɨռƈɛ ȶɦɛʏ'ʀɛ *ʍǟʀӄɛʀ ȶʀǟɨȶֆ* (ȶɦɛʏ ɦǟʋɛ ռօ ǟֆֆօƈɨǟȶɛɖ ɨȶɛʍֆ ʟɨӄɛ
ʍɛȶɦօɖֆ), ƈօʀʀɛƈȶʟʏ ɨʍքʟɛʍɛռȶɛɖ ֆɨʍքʟʏ ʍɛǟռֆ ȶɦǟȶ ȶɦɛʏ ɦǟʋɛ ȶɦɛ ɨռȶʀɨռֆɨƈ
քʀօքɛʀȶɨɛֆ ǟռ ɨʍքʟɛʍɛռȶօʀ ֆɦօʊʟɖ ɦǟʋɛ. Ɨռƈօʀʀɛƈȶʟʏ ɨʍքʟɛʍɛռȶɨռɢ Ֆɛռɖ օʀ Ֆʏռƈ ƈǟռ
ƈǟʊֆɛ Ʊռɖɛʄɨռɛɖ Ɓɛɦǟʋɨօʀ.

Ֆɛռɖ ǟռɖ Ֆʏռƈ ǟʀɛ ǟʟֆօ ǟʊȶօʍǟȶɨƈǟʟʟʏ ɖɛʀɨʋɛɖ ȶʀǟɨȶֆ. Ƭɦɨֆ ʍɛǟռֆ ȶɦǟȶ, ʊռʟɨӄɛ
ɛʋɛʀʏ օȶɦɛʀ ȶʀǟɨȶ, ɨʄ ǟ ȶʏքɛ ɨֆ ƈօʍքօֆɛɖ ɛռȶɨʀɛʟʏ օʄ Ֆɛռɖ օʀ Ֆʏռƈ ȶʏքɛֆ, ȶɦɛռ ɨȶ
ɨֆ Ֆɛռɖ օʀ Ֆʏռƈ. Ǟʟʍօֆȶ ǟʟʟ քʀɨʍɨȶɨʋɛֆ ǟʀɛ Ֆɛռɖ ǟռɖ Ֆʏռƈ, ǟռɖ ǟֆ ǟ ƈօռֆɛզʊɛռƈɛ
քʀɛȶȶʏ ʍʊƈɦ ǟʟʟ ȶʏքɛֆ ʏօʊ'ʟʟ ɛʋɛʀ ɨռȶɛʀǟƈȶ աɨȶɦ ǟʀɛ Ֆɛռɖ ǟռɖ Ֆʏռƈ.

Ɱǟʝօʀ ɛӼƈɛքȶɨօռֆ ɨռƈʟʊɖɛ:

* ʀǟա քօɨռȶɛʀֆ ǟʀɛ ռɛɨȶɦɛʀ Ֆɛռɖ ռօʀ Ֆʏռƈ (ɮɛƈǟʊֆɛ ȶɦɛʏ ɦǟʋɛ ռօ ֆǟʄɛȶʏ ɢʊǟʀɖֆ).
* `ƱռֆǟʄɛƇɛʟʟ` ɨֆռ'ȶ Ֆʏռƈ (ǟռɖ ȶɦɛʀɛʄօʀɛ `Ƈɛʟʟ` ǟռɖ `ƦɛʄƇɛʟʟ` ǟʀɛռ'ȶ).
* `Ʀƈ` ɨֆռ'ȶ Ֆɛռɖ օʀ Ֆʏռƈ (ɮɛƈǟʊֆɛ ȶɦɛ ʀɛʄƈօʊռȶ ɨֆ ֆɦǟʀɛɖ ǟռɖ ʊռֆʏռƈɦʀօռɨʐɛɖ).

`Ʀƈ` ǟռɖ `ƱռֆǟʄɛƇɛʟʟ` ǟʀɛ ʋɛʀʏ ʄʊռɖǟʍɛռȶǟʟʟʏ ռօȶ ȶɦʀɛǟɖ-ֆǟʄɛ: ȶɦɛʏ ɛռǟɮʟɛ
ʊռֆʏռƈɦʀօռɨʐɛɖ ֆɦǟʀɛɖ ʍʊȶǟɮʟɛ ֆȶǟȶɛ. Ӈօաɛʋɛʀ ʀǟա քօɨռȶɛʀֆ ǟʀɛ, ֆȶʀɨƈȶʟʏ
ֆքɛǟӄɨռɢ, ʍǟʀӄɛɖ ǟֆ ȶɦʀɛǟɖ-ʊռֆǟʄɛ ǟֆ ʍօʀɛ օʄ ǟ *ʟɨռȶ*. Ɖօɨռɢ ǟռʏȶɦɨռɢ ʊֆɛʄʊʟ
աɨȶɦ ǟ ʀǟա քօɨռȶɛʀ ʀɛզʊɨʀɛֆ ɖɛʀɛʄɛʀɛռƈɨռɢ ɨȶ, աɦɨƈɦ ɨֆ ǟʟʀɛǟɖʏ ʊռֆǟʄɛ. Ɨռ ȶɦǟȶ
ֆɛռֆɛ, օռɛ ƈօʊʟɖ ǟʀɢʊɛ ȶɦǟȶ ɨȶ աօʊʟɖ ɮɛ "ʄɨռɛ" ʄօʀ ȶɦɛʍ ȶօ ɮɛ ʍǟʀӄɛɖ ǟֆ ȶɦʀɛǟɖ
ֆǟʄɛ.

Ӈօաɛʋɛʀ ɨȶ'ֆ ɨʍքօʀȶǟռȶ ȶɦǟȶ ȶɦɛʏ ǟʀɛռ'ȶ ȶɦʀɛǟɖ-ֆǟʄɛ ȶօ քʀɛʋɛռȶ ȶʏքɛֆ ȶɦǟȶ
ƈօռȶǟɨռ ȶɦɛʍ ʄʀօʍ ɮɛɨռɢ ǟʊȶօʍǟȶɨƈǟʟʟʏ ʍǟʀӄɛɖ ǟֆ ȶɦʀɛǟɖ-ֆǟʄɛ. Ƭɦɛֆɛ ȶʏքɛֆ ɦǟʋɛ
ռօռ-ȶʀɨʋɨǟʟ ʊռȶʀǟƈӄɛɖ օառɛʀֆɦɨք, ǟռɖ ɨȶ'ֆ ʊռʟɨӄɛʟʏ ȶɦǟȶ ȶɦɛɨʀ ǟʊȶɦօʀ աǟֆ
ռɛƈɛֆֆǟʀɨʟʏ ȶɦɨռӄɨռɢ ɦǟʀɖ ǟɮօʊȶ ȶɦʀɛǟɖ ֆǟʄɛȶʏ. Ɨռ ȶɦɛ ƈǟֆɛ օʄ `Ʀƈ`, աɛ ɦǟʋɛ ǟ ռɨƈɛ
ɛӼǟʍքʟɛ օʄ ǟ ȶʏքɛ ȶɦǟȶ ƈօռȶǟɨռֆ ǟ `*ʍʊȶ` ȶɦǟȶ ɨֆ ɖɛʄɨռɨȶɛʟʏ ռօȶ ȶɦʀɛǟɖ-ֆǟʄɛ.

Ƭʏքɛֆ ȶɦǟȶ ǟʀɛռ'ȶ ǟʊȶօʍǟȶɨƈǟʟʟʏ ɖɛʀɨʋɛɖ ƈǟռ ֆɨʍքʟʏ ɨʍքʟɛʍɛռȶ ȶɦɛʍ ɨʄ ɖɛֆɨʀɛɖ:

```rust
struct MyBox(*mut u8);

unsafe impl Send for MyBox {}
unsafe impl Sync for MyBox {}
```

Ɨռ ȶɦɛ *ɨռƈʀɛɖɨɮʟʏ ʀǟʀɛ* ƈǟֆɛ ȶɦǟȶ ǟ ȶʏքɛ ɨֆ ɨռǟքքʀօքʀɨǟȶɛʟʏ ǟʊȶօʍǟȶɨƈǟʟʟʏ
ɖɛʀɨʋɛɖ ȶօ ɮɛ Ֆɛռɖ օʀ Ֆʏռƈ, ȶɦɛռ օռɛ ƈǟռ ǟʟֆօ ʊռɨʍքʟɛʍɛռȶ Ֆɛռɖ ǟռɖ Ֆʏռƈ:

```rust
#![feature(negative_impls)]

// I have some magic semantics for some synchronization primitive!
struct SpecialThreadToken(u8);

impl !Send for SpecialThreadToken {}
impl !Sync for SpecialThreadToken {}
```

Ռօȶɛ ȶɦǟȶ *ɨռ ǟռɖ օʄ ɨȶֆɛʟʄ* ɨȶ ɨֆ ɨʍքօֆֆɨɮʟɛ ȶօ ɨռƈօʀʀɛƈȶʟʏ ɖɛʀɨʋɛ Ֆɛռɖ ǟռɖ
Ֆʏռƈ. Øռʟʏ ȶʏքɛֆ ȶɦǟȶ ǟʀɛ ǟֆƈʀɨɮɛɖ ֆքɛƈɨǟʟ ʍɛǟռɨռɢ ɮʏ օȶɦɛʀ ʊռֆǟʄɛ ƈօɖɛ ƈǟռ
քօֆֆɨɮʟʏ ƈǟʊֆɛ ȶʀօʊɮʟɛ ɮʏ ɮɛɨռɢ ɨռƈօʀʀɛƈȶʟʏ Ֆɛռɖ օʀ Ֆʏռƈ.

Ɱօֆȶ ʊֆɛֆ օʄ ʀǟա քօɨռȶɛʀֆ ֆɦօʊʟɖ ɮɛ ɛռƈǟքֆʊʟǟȶɛɖ ɮɛɦɨռɖ ǟ ֆʊʄʄɨƈɨɛռȶ ǟɮֆȶʀǟƈȶɨօռ
ȶɦǟȶ Ֆɛռɖ ǟռɖ Ֆʏռƈ ƈǟռ ɮɛ ɖɛʀɨʋɛɖ. Ƒօʀ ɨռֆȶǟռƈɛ ǟʟʟ օʄ Ʀʊֆȶ'ֆ ֆȶǟռɖǟʀɖ
ƈօʟʟɛƈȶɨօռֆ ǟʀɛ Ֆɛռɖ ǟռɖ Ֆʏռƈ (աɦɛռ ȶɦɛʏ ƈօռȶǟɨռ Ֆɛռɖ ǟռɖ Ֆʏռƈ ȶʏքɛֆ) ɨռ ֆքɨȶɛ
օʄ ȶɦɛɨʀ քɛʀʋǟֆɨʋɛ ʊֆɛ օʄ ʀǟա քօɨռȶɛʀֆ ȶօ ʍǟռǟɢɛ ǟʟʟօƈǟȶɨօռֆ ǟռɖ ƈօʍքʟɛӼ օառɛʀֆɦɨք.
Ֆɨʍɨʟǟʀʟʏ, ʍօֆȶ ɨȶɛʀǟȶօʀֆ ɨռȶօ ȶɦɛֆɛ ƈօʟʟɛƈȶɨօռֆ ǟʀɛ Ֆɛռɖ ǟռɖ Ֆʏռƈ ɮɛƈǟʊֆɛ ȶɦɛʏ
ʟǟʀɢɛʟʏ ɮɛɦǟʋɛ ʟɨӄɛ ǟռ `&` օʀ `&ʍʊȶ` ɨռȶօ ȶɦɛ ƈօʟʟɛƈȶɨօռ.

## ƐӼǟʍքʟɛ

[`ƁօӼ`][ɮօӼ-ɖօƈ] ɨֆ ɨʍքʟɛʍɛռȶɛɖ ǟֆ ɨȶֆ օառ ֆքɛƈɨǟʟ ɨռȶʀɨռֆɨƈ ȶʏքɛ ɮʏ ȶɦɛ
ƈօʍքɨʟɛʀ ʄօʀ [ʋǟʀɨօʊֆ ʀɛǟֆօռֆ][ɮօӼ-ɨֆ-ֆքɛƈɨǟʟ], ɮʊȶ աɛ ƈǟռ ɨʍքʟɛʍɛռȶ ֆօʍɛȶɦɨռɢ
աɨȶɦ ֆɨʍɨʟǟʀ-ɨֆɦ ɮɛɦǟʋɨօʀ օʊʀֆɛʟʋɛֆ ȶօ ֆɛɛ ǟռ ɛӼǟʍքʟɛ օʄ աɦɛռ ɨȶ ɨֆ ֆօʊռɖ ȶօ
ɨʍքʟɛʍɛռȶ Ֆɛռɖ ǟռɖ Ֆʏռƈ. Łɛȶ'ֆ ƈǟʟʟ ɨȶ ǟ `Ƈǟʀȶօռ`.

Ɯɛ ֆȶǟʀȶ ɮʏ աʀɨȶɨռɢ ƈօɖɛ ȶօ ȶǟӄɛ ǟ ʋǟʟʊɛ ǟʟʟօƈǟȶɛɖ օռ ȶɦɛ ֆȶǟƈӄ ǟռɖ ȶʀǟռֆʄɛʀ ɨȶ
ȶօ ȶɦɛ ɦɛǟք.

```rust
# pub mod libc {
#    pub use ::std::os::raw::{c_int, c_void};
#    #[allow(non_camel_case_types)]
#    pub type size_t = usize;
#    unsafe extern "C" { pub fn posix_memalign(memptr: *mut *mut c_void, align: size_t, size: size_t) -> c_int; }
# }
use std::{
    mem::{align_of, size_of},
    ptr,
    cmp::max,
};

struct Carton<T>(ptr::NonNull<T>);

impl<T> Carton<T> {
    pub fn new(value: T) -> Self {
        // Allocate enough memory on the heap to store one T.
        assert_ne!(size_of::<T>(), 0, "Zero-sized types are out of the scope of this example");
        let mut memptr: *mut T = ptr::null_mut();
        unsafe {
            let ret = libc::posix_memalign(
                (&mut memptr as *mut *mut T).cast(),
                max(align_of::<T>(), size_of::<usize>()),
                size_of::<T>()
            );
            assert_eq!(ret, 0, "Failed to allocate or invalid alignment");
        };

        // NonNull is just a wrapper that enforces that the pointer isn't null.
        let ptr = {
            // Safety: memptr is dereferenceable because we created it from a
            // reference and have exclusive access.
            ptr::NonNull::new(memptr)
                .expect("Guaranteed non-null if posix_memalign returns 0")
        };

        // Move value from the stack to the location we allocated on the heap.
        unsafe {
            // Safety: If non-null, posix_memalign gives us a ptr that is valid
            // for writes and properly aligned.
            ptr.as_ptr().write(value);
        }

        Self(ptr)
    }
}
```

Ƭɦɨֆ ɨֆռ'ȶ ʋɛʀʏ ʊֆɛʄʊʟ, ɮɛƈǟʊֆɛ օռƈɛ օʊʀ ʊֆɛʀֆ ɢɨʋɛ ʊֆ ǟ ʋǟʟʊɛ ȶɦɛʏ ɦǟʋɛ ռօ աǟʏ
ȶօ ǟƈƈɛֆֆ ɨȶ. [`ƁօӼ`][ɮօӼ-ɖօƈ] ɨʍքʟɛʍɛռȶֆ [`Ɖɛʀɛʄ`][ɖɛʀɛʄ-ɖօƈ] ǟռɖ
[`ƉɛʀɛʄⱮʊȶ`][ɖɛʀɛʄ-ʍʊȶ-ɖօƈ] ֆօ ȶɦǟȶ ʏօʊ ƈǟռ ǟƈƈɛֆֆ ȶɦɛ ɨռռɛʀ ʋǟʟʊɛ. Łɛȶ'ֆ ɖօ
ȶɦǟȶ.

```rust
use std::ops::{Deref, DerefMut};

# struct Carton<T>(std::ptr::NonNull<T>);
#
impl<T> Deref for Carton<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        unsafe {
            // Safety: The pointer is aligned, initialized, and dereferenceable
            //   by the logic in [`Self::new`]. We require readers to borrow the
            //   Carton, and the lifetime of the return value is elided to the
            //   lifetime of the input. This means the borrow checker will
            //   enforce that no one can mutate the contents of the Carton until
            //   the reference returned is dropped.
            self.0.as_ref()
        }
    }
}

impl<T> DerefMut for Carton<T> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe {
            // Safety: The pointer is aligned, initialized, and dereferenceable
            //   by the logic in [`Self::new`]. We require writers to mutably
            //   borrow the Carton, and the lifetime of the return value is
            //   elided to the lifetime of the input. This means the borrow
            //   checker will enforce that no one else can access the contents
            //   of the Carton until the mutable reference returned is dropped.
            self.0.as_mut()
        }
    }
}
```

Ƒɨռǟʟʟʏ, ʟɛȶ'ֆ ȶɦɨռӄ ǟɮօʊȶ աɦɛȶɦɛʀ օʊʀ `Ƈǟʀȶօռ` ɨֆ Ֆɛռɖ ǟռɖ Ֆʏռƈ. Ֆօʍɛȶɦɨռɢ ƈǟռ
ֆǟʄɛʟʏ ɮɛ Ֆɛռɖ ʊռʟɛֆֆ ɨȶ ֆɦǟʀɛֆ ʍʊȶǟɮʟɛ ֆȶǟȶɛ աɨȶɦ ֆօʍɛȶɦɨռɢ ɛʟֆɛ աɨȶɦօʊȶ
ɛռʄօʀƈɨռɢ ɛӼƈʟʊֆɨʋɛ ǟƈƈɛֆֆ ȶօ ɨȶ. Ɛǟƈɦ `Ƈǟʀȶօռ` ɦǟֆ ǟ ʊռɨզʊɛ քօɨռȶɛʀ, ֆօ
աɛ'ʀɛ ɢօօɖ.

```rust
# struct Carton<T>(std::ptr::NonNull<T>);
// Safety: No one besides us has the raw pointer, so we can safely transfer the
// Carton to another thread if T can be safely transferred.
unsafe impl<T> Send for Carton<T> where T: Send {}
```

Ɯɦǟȶ ǟɮօʊȶ Ֆʏռƈ? Ƒօʀ `Ƈǟʀȶօռ` ȶօ ɮɛ Ֆʏռƈ աɛ ɦǟʋɛ ȶօ ɛռʄօʀƈɛ ȶɦǟȶ ʏօʊ ƈǟռ'ȶ
աʀɨȶɛ ȶօ ֆօʍɛȶɦɨռɢ ֆȶօʀɛɖ ɨռ ǟ `&Ƈǟʀȶօռ` աɦɨʟɛ ȶɦǟȶ ֆǟʍɛ ֆօʍɛȶɦɨռɢ ƈօʊʟɖ ɮɛ ʀɛǟɖ
օʀ աʀɨȶȶɛռ ȶօ ʄʀօʍ ǟռօȶɦɛʀ `&Ƈǟʀȶօռ`. Ֆɨռƈɛ ʏօʊ ռɛɛɖ ǟռ `&ʍʊȶ Ƈǟʀȶօռ` ȶօ
աʀɨȶɛ ȶօ ȶɦɛ քօɨռȶɛʀ, ǟռɖ ȶɦɛ ɮօʀʀօա ƈɦɛƈӄɛʀ ɛռʄօʀƈɛֆ ȶɦǟȶ ʍʊȶǟɮʟɛ
ʀɛʄɛʀɛռƈɛֆ ʍʊֆȶ ɮɛ ɛӼƈʟʊֆɨʋɛ, ȶɦɛʀɛ ǟʀɛ ռօ ֆօʊռɖռɛֆֆ ɨֆֆʊɛֆ ʍǟӄɨռɢ `Ƈǟʀȶօռ`
ֆʏռƈ ɛɨȶɦɛʀ.

```rust
# struct Carton<T>(std::ptr::NonNull<T>);
// Safety: Since there exists a public way to go from a `&Carton<T>` to a `&T`
// in an unsynchronized fashion (such as `Deref`), then `Carton<T>` can't be
// `Sync` if `T` isn't.
// Conversely, `Carton` itself does not use any interior mutability whatsoever:
// all the mutations are performed through an exclusive reference (`&mut`). This
// means it suffices that `T` be `Sync` for `Carton<T>` to be `Sync`:
unsafe impl<T> Sync for Carton<T> where T: Sync  {}
```

Ɯɦɛռ աɛ ǟֆֆɛʀȶ օʊʀ ȶʏքɛ ɨֆ Ֆɛռɖ ǟռɖ Ֆʏռƈ աɛ ʊֆʊǟʟʟʏ ռɛɛɖ ȶօ ɛռʄօʀƈɛ ȶɦǟȶ ɛʋɛʀʏ
ƈօռȶǟɨռɛɖ ȶʏքɛ ɨֆ Ֆɛռɖ ǟռɖ Ֆʏռƈ. Ɯɦɛռ աʀɨȶɨռɢ ƈʊֆȶօʍ ȶʏքɛֆ ȶɦǟȶ ɮɛɦǟʋɛ ʟɨӄɛ
ֆȶǟռɖǟʀɖ ʟɨɮʀǟʀʏ ȶʏքɛֆ աɛ ƈǟռ ǟֆֆɛʀȶ ȶɦǟȶ աɛ ɦǟʋɛ ȶɦɛ ֆǟʍɛ ʀɛզʊɨʀɛʍɛռȶֆ.
Ƒօʀ ɛӼǟʍքʟɛ, ȶɦɛ ʄօʟʟօաɨռɢ ƈօɖɛ ǟֆֆɛʀȶֆ ȶɦǟȶ ǟ Ƈǟʀȶօռ ɨֆ Ֆɛռɖ ɨʄ ȶɦɛ ֆǟʍɛ
ֆօʀȶ օʄ ƁօӼ աօʊʟɖ ɮɛ Ֆɛռɖ, աɦɨƈɦ ɨռ ȶɦɨֆ ƈǟֆɛ ɨֆ ȶɦɛ ֆǟʍɛ ǟֆ ֆǟʏɨռɢ Ƭ ɨֆ Ֆɛռɖ.

```rust
# struct Carton<T>(std::ptr::NonNull<T>);
unsafe impl<T> Send for Carton<T> where Box<T>: Send {}
```

Ʀɨɢɦȶ ռօա `Ƈǟʀȶօռ<Ƭ>` ɦǟֆ ǟ ʍɛʍօʀʏ ʟɛǟӄ, ǟֆ ɨȶ ռɛʋɛʀ ʄʀɛɛֆ ȶɦɛ ʍɛʍօʀʏ ɨȶ ǟʟʟօƈǟȶɛֆ.
Øռƈɛ աɛ ʄɨӼ ȶɦǟȶ աɛ ɦǟʋɛ ǟ ռɛա ʀɛզʊɨʀɛʍɛռȶ աɛ ɦǟʋɛ ȶօ ɛռֆʊʀɛ աɛ ʍɛɛȶ ȶօ ɮɛ Ֆɛռɖ:
աɛ ռɛɛɖ ȶօ ӄռօա `ʄʀɛɛ` ƈǟռ ɮɛ ƈǟʟʟɛɖ օռ ǟ քօɨռȶɛʀ ȶɦǟȶ աǟֆ ʏɨɛʟɖɛɖ ɮʏ ǟռ
ǟʟʟօƈǟȶɨօռ ɖօռɛ օռ ǟռօȶɦɛʀ ȶɦʀɛǟɖ. Ɯɛ ƈǟռ ƈɦɛƈӄ ȶɦɨֆ ɨֆ ȶʀʊɛ ɨռ ȶɦɛ ɖօƈֆ ʄօʀ
[`ʟɨɮƈ::ʄʀɛɛ`][ʟɨɮƈ-ʄʀɛɛ-ɖօƈֆ].

```rust
# struct Carton<T>(std::ptr::NonNull<T>);
# mod libc {
#     pub use ::std::os::raw::c_void;
#     unsafe extern "C" { pub fn free(p: *mut c_void); }
# }
impl<T> Drop for Carton<T> {
    fn drop(&mut self) {
        unsafe {
            libc::free(self.0.as_ptr().cast());
        }
    }
}
```

Ǟ ռɨƈɛ ɛӼǟʍքʟɛ աɦɛʀɛ ȶɦɨֆ ɖօɛֆ ռօȶ ɦǟքքɛռ ɨֆ աɨȶɦ ǟ ⱮʊȶɛӼƓʊǟʀɖ: ռօȶɨƈɛ ɦօա
[ɨȶ ɨֆ ռօȶ Ֆɛռɖ][ʍʊȶɛӼ-ɢʊǟʀɖ-ռօȶ-ֆɛռɖ-ɖօƈֆ-ʀֆ]. Ƭɦɛ ɨʍքʟɛʍɛռȶǟȶɨօռ օʄ ⱮʊȶɛӼƓʊǟʀɖ
[ʊֆɛֆ ʟɨɮʀǟʀɨɛֆ][ʍʊȶɛӼ-ɢʊǟʀɖ-ռօȶ-ֆɛռɖ-ƈօʍʍɛռȶ] ȶɦǟȶ ʀɛզʊɨʀɛ ʏօʊ ȶօ ɛռֆʊʀɛ ʏօʊ
ɖօռ'ȶ ȶʀʏ ȶօ ʄʀɛɛ ǟ ʟօƈӄ ȶɦǟȶ ʏօʊ ǟƈզʊɨʀɛɖ ɨռ ǟ ɖɨʄʄɛʀɛռȶ ȶɦʀɛǟɖ. Ɨʄ ʏօʊ աɛʀɛ
ǟɮʟɛ ȶօ Ֆɛռɖ ǟ ⱮʊȶɛӼƓʊǟʀɖ ȶօ ǟռօȶɦɛʀ ȶɦʀɛǟɖ ȶɦɛ ɖɛֆȶʀʊƈȶօʀ աօʊʟɖ ʀʊռ ɨռ ȶɦɛ
ȶɦʀɛǟɖ ʏօʊ ֆɛռȶ ɨȶ ȶօ, ʋɨօʟǟȶɨռɢ ȶɦɛ ʀɛզʊɨʀɛʍɛռȶ. ⱮʊȶɛӼƓʊǟʀɖ ƈǟռ ֆȶɨʟʟ ɮɛ Ֆʏռƈ
ɮɛƈǟʊֆɛ ǟʟʟ ʏօʊ ƈǟռ ֆɛռɖ ȶօ ǟռօȶɦɛʀ ȶɦʀɛǟɖ ɨֆ ǟռ `&ⱮʊȶɛӼƓʊǟʀɖ` ǟռɖ ɖʀօքքɨռɢ ǟ
ʀɛʄɛʀɛռƈɛ ɖօɛֆ ռօȶɦɨռɢ.

ƬØƉØ: ɮɛȶȶɛʀ ɛӼքʟǟɨռ աɦǟȶ ƈǟռ օʀ ƈǟռ'ȶ ɮɛ Ֆɛռɖ օʀ Ֆʏռƈ. Ֆʊʄʄɨƈɨɛռȶ ȶօ ǟքքɛǟʟ
օռʟʏ ȶօ ɖǟȶǟ ʀǟƈɛֆ?

[ʊռֆǟʄɛ ȶʀǟɨȶֆ]: safe-unsafe-meaning.html
[ɮօӼ-ɖօƈ]: https://doc.rust-lang.org/std/boxed/struct.Box.html
[ɮօӼ-ɨֆ-ֆքɛƈɨǟʟ]: https://manishearth.github.io/blog/2017/01/10/rust-tidbits-box-is-special/
[ɖɛʀɛʄ-ɖօƈ]: https://doc.rust-lang.org/core/ops/trait.Deref.html
[ɖɛʀɛʄ-ʍʊȶ-ɖօƈ]: https://doc.rust-lang.org/core/ops/trait.DerefMut.html
[ʍʊȶɛӼ-ɢʊǟʀɖ-ռօȶ-ֆɛռɖ-ɖօƈֆ-ʀֆ]: https://doc.rust-lang.org/std/sync/struct.MutexGuard.html#impl-Send-for-MutexGuard%3C'_,+T%3E
[ʍʊȶɛӼ-ɢʊǟʀɖ-ռօȶ-ֆɛռɖ-ƈօʍʍɛռȶ]: https://github.com/rust-lang/rust/issues/23465#issuecomment-82730326
[ʟɨɮƈ-ʄʀɛɛ-ɖօƈֆ]: https://linux.die.net/man/3/free
