# Ɖʀօքքɨռɢ

Ɯɛ ռօա ռɛɛɖ ǟ աǟʏ ȶօ ɖɛƈʀɛǟֆɛ ȶɦɛ ʀɛʄɛʀɛռƈɛ ƈօʊռȶ ǟռɖ ɖʀօք ȶɦɛ ɖǟȶǟ օռƈɛ ɨȶ ɨֆ
ʟօա ɛռօʊɢɦ, օȶɦɛʀաɨֆɛ ȶɦɛ ɖǟȶǟ աɨʟʟ ʟɨʋɛ ʄօʀɛʋɛʀ օռ ȶɦɛ ɦɛǟք.

Ƭօ ɖօ ȶɦɨֆ, աɛ ƈǟռ ɨʍքʟɛʍɛռȶ `Ɖʀօք`.

Ɓǟֆɨƈǟʟʟʏ, աɛ ռɛɛɖ ȶօ:

1. Ɖɛƈʀɛʍɛռȶ ȶɦɛ ʀɛʄɛʀɛռƈɛ ƈօʊռȶ
2. Ɨʄ ȶɦɛʀɛ ɨֆ օռʟʏ օռɛ ʀɛʄɛʀɛռƈɛ ʀɛʍǟɨռɨռɢ ȶօ ȶɦɛ ɖǟȶǟ, ȶɦɛռ:
3. Ǟȶօʍɨƈǟʟʟʏ ʄɛռƈɛ ȶɦɛ ɖǟȶǟ ȶօ քʀɛʋɛռȶ ʀɛօʀɖɛʀɨռɢ օʄ ȶɦɛ ʊֆɛ ǟռɖ ɖɛʟɛȶɨօռ օʄ
   ȶɦɛ ɖǟȶǟ
4. Ɖʀօք ȶɦɛ ɨռռɛʀ ɖǟȶǟ

Ƒɨʀֆȶ, աɛ'ʟʟ ռɛɛɖ ȶօ ɢɛȶ ǟƈƈɛֆֆ ȶօ ȶɦɛ `ǞʀƈƗռռɛʀ`:

<!-- ignore: simplified code -->
```rust,ignore
let inner = unsafe { self.ptr.as_ref() };
```

Ռօա, աɛ ռɛɛɖ ȶօ ɖɛƈʀɛʍɛռȶ ȶɦɛ ʀɛʄɛʀɛռƈɛ ƈօʊռȶ. Ƭօ ֆȶʀɛǟʍʟɨռɛ օʊʀ ƈօɖɛ, աɛ ƈǟռ
ǟʟֆօ ʀɛȶʊʀռ ɨʄ ȶɦɛ ʀɛȶʊʀռɛɖ ʋǟʟʊɛ ʄʀօʍ `ʄɛȶƈɦ_ֆʊɮ` (ȶɦɛ ʋǟʟʊɛ օʄ ȶɦɛ ʀɛʄɛʀɛռƈɛ
ƈօʊռȶ ɮɛʄօʀɛ ɖɛƈʀɛʍɛռȶɨռɢ ɨȶ) ɨֆ ռօȶ ɛզʊǟʟ ȶօ `1` (աɦɨƈɦ ɦǟքքɛռֆ աɦɛռ աɛ ǟʀɛ ռօȶ
ȶɦɛ ʟǟֆȶ ʀɛʄɛʀɛռƈɛ ȶօ ȶɦɛ ɖǟȶǟ).

<!-- ignore: simplified code -->
```rust,ignore
if inner.rc.fetch_sub(1, Ordering::Release) != 1 {
    return;
}
```

Ɯɛ ȶɦɛռ ռɛɛɖ ȶօ ƈʀɛǟȶɛ ǟռ ǟȶօʍɨƈ ʄɛռƈɛ ȶօ քʀɛʋɛռȶ ʀɛօʀɖɛʀɨռɢ օʄ ȶɦɛ ʊֆɛ օʄ ȶɦɛ
ɖǟȶǟ ǟռɖ ɖɛʟɛȶɨօռ օʄ ȶɦɛ ɖǟȶǟ. Ǟֆ ɖɛֆƈʀɨɮɛɖ ɨռ [ȶɦɛ ֆȶǟռɖǟʀɖ ʟɨɮʀǟʀʏ'ֆ
ɨʍքʟɛʍɛռȶǟȶɨօռ օʄ `Ǟʀƈ`][3]:
> Ƭɦɨֆ ʄɛռƈɛ ɨֆ ռɛɛɖɛɖ ȶօ քʀɛʋɛռȶ ʀɛօʀɖɛʀɨռɢ օʄ ʊֆɛ օʄ ȶɦɛ ɖǟȶǟ ǟռɖ ɖɛʟɛȶɨօռ օʄ
> ȶɦɛ ɖǟȶǟ. Ɓɛƈǟʊֆɛ ɨȶ ɨֆ ʍǟʀӄɛɖ `Ʀɛʟɛǟֆɛ`, ȶɦɛ ɖɛƈʀɛǟֆɨռɢ օʄ ȶɦɛ ʀɛʄɛʀɛռƈɛ
> ƈօʊռȶ ֆʏռƈɦʀօռɨʐɛֆ աɨȶɦ ȶɦɨֆ `Ǟƈզʊɨʀɛ` ʄɛռƈɛ. Ƭɦɨֆ ʍɛǟռֆ ȶɦǟȶ ʊֆɛ օʄ ȶɦɛ ɖǟȶǟ
> ɦǟքքɛռֆ ɮɛʄօʀɛ ɖɛƈʀɛǟֆɨռɢ ȶɦɛ ʀɛʄɛʀɛռƈɛ ƈօʊռȶ, աɦɨƈɦ ɦǟքքɛռֆ ɮɛʄօʀɛ ȶɦɨֆ
> ʄɛռƈɛ, աɦɨƈɦ ɦǟքքɛռֆ ɮɛʄօʀɛ ȶɦɛ ɖɛʟɛȶɨօռ օʄ ȶɦɛ ɖǟȶǟ.
>
> Ǟֆ ɛӼքʟǟɨռɛɖ ɨռ ȶɦɛ [Ɓօօֆȶ ɖօƈʊʍɛռȶǟȶɨօռ][1],
>
> > Ɨȶ ɨֆ ɨʍքօʀȶǟռȶ ȶօ ɛռʄօʀƈɛ ǟռʏ քօֆֆɨɮʟɛ ǟƈƈɛֆֆ ȶօ ȶɦɛ օɮʝɛƈȶ ɨռ օռɛ
> > ȶɦʀɛǟɖ (ȶɦʀօʊɢɦ ǟռ ɛӼɨֆȶɨռɢ ʀɛʄɛʀɛռƈɛ) ȶօ *ɦǟքքɛռ ɮɛʄօʀɛ* ɖɛʟɛȶɨռɢ
> > ȶɦɛ օɮʝɛƈȶ ɨռ ǟ ɖɨʄʄɛʀɛռȶ ȶɦʀɛǟɖ. Ƭɦɨֆ ɨֆ ǟƈɦɨɛʋɛɖ ɮʏ ǟ "ʀɛʟɛǟֆɛ"
> > օքɛʀǟȶɨօռ ǟʄȶɛʀ ɖʀօքքɨռɢ ǟ ʀɛʄɛʀɛռƈɛ (ǟռʏ ǟƈƈɛֆֆ ȶօ ȶɦɛ օɮʝɛƈȶ
> > ȶɦʀօʊɢɦ ȶɦɨֆ ʀɛʄɛʀɛռƈɛ ʍʊֆȶ օɮʋɨօʊֆʟʏ ɦǟքքɛռɛɖ ɮɛʄօʀɛ), ǟռɖ ǟռ
> > "ǟƈզʊɨʀɛ" օքɛʀǟȶɨօռ ɮɛʄօʀɛ ɖɛʟɛȶɨռɢ ȶɦɛ օɮʝɛƈȶ.
>
> Ɨռ քǟʀȶɨƈʊʟǟʀ, աɦɨʟɛ ȶɦɛ ƈօռȶɛռȶֆ օʄ ǟռ Ǟʀƈ ǟʀɛ ʊֆʊǟʟʟʏ ɨʍʍʊȶǟɮʟɛ, ɨȶ'ֆ
> քօֆֆɨɮʟɛ ȶօ ɦǟʋɛ ɨռȶɛʀɨօʀ աʀɨȶɛֆ ȶօ ֆօʍɛȶɦɨռɢ ʟɨӄɛ ǟ `ⱮʊȶɛӼ<Ƭ>`. Ֆɨռƈɛ ǟ ⱮʊȶɛӼ
> ɨֆ ռօȶ ǟƈզʊɨʀɛɖ աɦɛռ ɨȶ ɨֆ ɖɛʟɛȶɛɖ, աɛ ƈǟռ'ȶ ʀɛʟʏ օռ ɨȶֆ ֆʏռƈɦʀօռɨʐǟȶɨօռ ʟօɢɨƈ
> ȶօ ʍǟӄɛ աʀɨȶɛֆ ɨռ ȶɦʀɛǟɖ Ǟ ʋɨֆɨɮʟɛ ȶօ ǟ ɖɛֆȶʀʊƈȶօʀ ʀʊռռɨռɢ ɨռ ȶɦʀɛǟɖ Ɓ.
>
> Ǟʟֆօ ռօȶɛ ȶɦǟȶ ȶɦɛ Ǟƈզʊɨʀɛ ʄɛռƈɛ ɦɛʀɛ ƈօʊʟɖ քʀօɮǟɮʟʏ ɮɛ ʀɛքʟǟƈɛɖ աɨȶɦ ǟռ
> Ǟƈզʊɨʀɛ ʟօǟɖ, աɦɨƈɦ ƈօʊʟɖ ɨʍքʀօʋɛ քɛʀʄօʀʍǟռƈɛ ɨռ ɦɨɢɦʟʏ-ƈօռȶɛռɖɛɖ ֆɨȶʊǟȶɨօռֆ.
> Ֆɛɛ [2].
>
> [1]: https://www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html
> [2]: https://github.com/rust-lang/rust/pull/41714
[3]: https://github.com/rust-lang/rust/blob/e1884a8e3c3e813aada8254edfa120e85bf5ffca/library/alloc/src/sync.rs#L1440-L1467

Ƭօ ɖօ ȶɦɨֆ, աɛ ɖօ ȶɦɛ ʄօʟʟօաɨռɢ:

```rust
# use std::sync::atomic::Ordering;
use std::sync::atomic;
atomic::fence(Ordering::Acquire);
```

Ƒɨռǟʟʟʏ, աɛ ƈǟռ ɖʀօք ȶɦɛ ɖǟȶǟ ɨȶֆɛʟʄ. Ɯɛ ʊֆɛ `ƁօӼ::ʄʀօʍ_ʀǟա` ȶօ ɖʀօք ȶɦɛ ɮօӼɛɖ
`ǞʀƈƗռռɛʀ<Ƭ>` ǟռɖ ɨȶֆ ɖǟȶǟ. Ƭɦɨֆ ȶǟӄɛֆ ǟ `*ʍʊȶ Ƭ` ǟռɖ ռօȶ ǟ `ՌօռՌʊʟʟ<Ƭ>`, ֆօ աɛ
ʍʊֆȶ ƈօռʋɛʀȶ ʊֆɨռɢ `ՌօռՌʊʟʟ::ǟֆ_քȶʀ`.

<!-- ignore: simplified code -->
```rust,ignore
unsafe { Box::from_raw(self.ptr.as_ptr()); }
```

Ƭɦɨֆ ɨֆ ֆǟʄɛ ǟֆ աɛ ӄռօա աɛ ɦǟʋɛ ȶɦɛ ʟǟֆȶ քօɨռȶɛʀ ȶօ ȶɦɛ `ǞʀƈƗռռɛʀ` ǟռɖ ȶɦǟȶ ɨȶֆ
քօɨռȶɛʀ ɨֆ ʋǟʟɨɖ.

Ռօա, ʟɛȶ'ֆ աʀǟք ȶɦɨֆ ǟʟʟ ʊք ɨռֆɨɖɛ ȶɦɛ `Ɖʀօք` ɨʍքʟɛʍɛռȶǟȶɨօռ:

<!-- ignore: simplified code -->
```rust,ignore
impl<T> Drop for Arc<T> {
    fn drop(&mut self) {
        let inner = unsafe { self.ptr.as_ref() };
        if inner.rc.fetch_sub(1, Ordering::Release) != 1 {
            return;
        }
        // This fence is needed to prevent reordering of the use and deletion
        // of the data.
        atomic::fence(Ordering::Acquire);
        // This is safe as we know we have the last pointer to the `ArcInner`
        // and that its pointer is valid.
        unsafe { Box::from_raw(self.ptr.as_ptr()); }
    }
}
```
